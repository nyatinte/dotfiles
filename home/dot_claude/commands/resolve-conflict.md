---
allowed-tools: Bash(git status:*), Bash(git diff:*), Bash(git log:*), Bash(git branch --show-current), Bash(git show:*), Bash(git ls-files -u:*), Bash(git merge:*), Bash(git rebase:*), Bash(git add:*), Bash(git rebase --continue), Bash(git merge --continue), Bash(git rebase --abort), Bash(git merge --abort), Bash(gh pr list:*), Bash(gh pr view:*), Read(*), Edit(*)
denied-tools: Bash(git push:*), Bash(git commit -n:*), Bash(git commit --no-verify), Bash(git reset --hard:*), Write(*)
description: コンフリクトを解決するための支援コマンド
argument-hint: "[オプション: 解決の方針に関する追加コンテキスト]"
---

# Resolve Conflict

## コンテキスト

- 現在のブランチ: `!git branch --show-current`
- Gitステータス: `!git status`
- コンフリクトしているファイル一覧: `!git ls-files -u`
- 最近のコミット: `!git log --oneline -10`

## タスク

Git merge/rebaseで発生したコンフリクトを分析し、解決方針をユーザーに提案してから実際の解決作業を行います。

### 1. **コンフリクト状況の確認**

- `git status`でコンフリクト状態を確認
  - rebase中、merge中などの状態を特定
  - コンフリクトしているファイルの一覧を取得
- コンフリクト状態でない場合:
  - ユーザーに「現在コンフリクトは発生していません」と通知して終了

### 2. **コンフリクト内容の深い分析**

各コンフリクトファイルについて、文脈を理解するための情報収集:

**A. コンフリクト箇所の特定**
- ファイルの内容を読み込み、コンフリクトマーカー(`<<<<<<<`, `=======`, `>>>>>>>`)を特定
- コンフリクト箇所の変更内容を分析:
  - OURSの変更内容（現在のブランチの変更）
  - THEIRSの変更内容（マージ/リベース元の変更）
  - 変更の性質を理解（追加、削除、変更など）

**B. 変更の背景の理解**
- 各変更を導入したコミットを特定:
  - `git log -p --all -- <ファイル>`で該当ファイルの変更履歴を確認
  - コンフリクト箇所に関連するコミットメッセージを読み、変更の意図を理解
- ブランチの目的を確認:
  - 現在のブランチ名から目的を推測（例: `feat/`, `fix/`, `refactor/`など）
  - マージ元のブランチの履歴を確認

**C. 関連PRの確認**
- 現在のブランチに関連するPRを確認:
  ```bash
  gh pr list --head $(git branch --show-current)
  ```
- PRが存在する場合、PR説明やコメントから変更の意図を理解
- マージ元のブランチに関連する最近のPRも確認し、変更の文脈を把握

**D. コードの文脈分析**
- コンフリクト箇所の周辺コードを読み、機能的な文脈を理解
- 変更が影響する範囲を特定（関数、クラス、モジュールなど）
- 両方の変更が何を達成しようとしているか分析

### 3. **意味論的な解決方針の提案**

収集した情報をもとに、`AskUserQuestion`を使用して**意味論的な選択肢**を提示:

各コンフリクトについて、以下のような具体的で文脈に基づいた選択肢を作成:

**例1: 機能追加のコンフリクト**
1. **[ブランチ名]の新機能を優先**
   - description: コミット[hash]で追加された[機能の説明]を保持。[理由]
2. **[マージ元]の実装を優先**
   - description: コミット[hash]の[機能の説明]を採用。[理由]
3. **両機能を統合**
   - description: [機能A]と[機能B]の両方を残し、互いに干渉しないよう調整
4. **手動で解決**
   - description: より複雑な調整が必要な場合

**例2: リファクタリングのコンフリクト**
1. **[新しい設計パターン]を採用**
   - description: [ブランチ名]で導入された[パターン名]に統一。より[メリット]
2. **[既存の実装]を維持**
   - description: [マージ元]の実装を保持。[理由]
3. **段階的にマージ**
   - description: 両方の変更を取り込み、一貫性を保つよう調整
4. **手動で解決**

**重要**:
- 単純に「OURS」「THEIRS」ではなく、**何をしようとしている変更か**を明確に説明
- コミットメッセージ、PR情報、コード文脈から推測される**変更の意図**を含める
- 推奨される選択肢には**なぜその選択が適切か**の理由を付ける
- 各選択肢のdescriptionには、技術的な影響や今後の保守性への影響も含める

### 4. **解決作業の実行**

ユーザーの承認後、選択された方針に基づいて解決を実行:

1. **OURSを採用する場合**:
   - `git checkout --ours <ファイル>`を実行
   - `git add <ファイル>`でステージング

2. **THEIRSを採用する場合**:
   - `git checkout --theirs <ファイル>`を実行
   - `git add <ファイル>`でステージング

3. **両方をマージする場合**:
   - `Edit`ツールを使用してコンフリクトマーカーを削除し、両方の変更を統合
   - `git add <ファイル>`でステージング

4. **手動解決の場合**:
   - ユーザーに「手動で解決してください」と通知
   - 解決後に実行すべきコマンドを案内
   - 処理を終了

### 5. **解決後の処理**

全てのコンフリクトが解決された後:
- `git status`で全てのコンフリクトが解決されたことを確認
- rebase/merge状態に応じて適切なコマンドを提案:
  - rebase中: `git rebase --continue`の実行を提案
  - merge中: `git merge --continue`または`git commit`の実行を提案
- ユーザーに`AskUserQuestion`で続行するか確認
  - 続行する場合、適切なコマンドを実行
  - 中止する場合、`git rebase --abort`または`git merge --abort`のオプションも提示

## 重要な注意事項

- **慎重な分析**: コンフリクトの内容を慎重に分析し、誤った解決を避ける
- **ユーザー確認**: 解決方針は必ずユーザーに確認してから実行
- **中止オプション**: いつでも操作を中止できるよう、abort オプションを提示
- **ユーザーとのコミュニケーション**: 日本語で応答
- **段階的な解決**: 複数ファイルがコンフリクトしている場合、1ファイルずつ解決を進める

## エラーハンドリング

- コンフリクト解決中にエラーが発生した場合:
  - エラー内容をユーザーに報告
  - `git status`で現在の状態を確認
  - 次のステップをユーザーに提案（再試行、中止、手動解決など）

## ユーザー追加指示

$ARGUMENTS